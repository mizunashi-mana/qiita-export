---
title: StrictData拡張について
tags: Haskell
author: Mizunashi_Mana
slide: false
---
Haskellプログラマーなら誰でも経験するスペースリーク。

そして、スペースリークを経験したHaskellerは、おとなしくHaskellを捨て遅延しない言語を使うか、全部バングパターンなり、不自然なパターンマッチなりを意識的に何でも書いていくようになるのだった。。。という時期がHaskell世界にはありました。

GHC8で大きく正格評価サポートが入りました。具体的には、Strict拡張とStrictData拡張です。果たして、これでHaskellerは平穏を取り戻せるのでしょうか！？

まあ、それはおいといて、今回はそもそもなぜこの拡張が必要なのか、そしてAdventCalendarらしく~~（僕の実力が足りないので）~~ゆるふわにStrictData拡張について紹介したいと思います。

## 多くのデータコンストラクタにはサンクを渡す必要はない

以下のようなデータについて考えてみます。

```haskell
data Size = Size Int deriving (Eq, Ord, Show)
```

単純に長さを表すデータです。ではこのデータを使って、リストのデータの長さを返す関数を実装してみましょう。

```haskell
listSize :: [a] -> Size
listSize = go $ Size 0 where
  go s []            = s
  go (Size s) (_:xs) = go (Size $ s + 1) xs
```

さて、この単純な関数の結果について少々考察してみます。関数自体は単純ですが、結果は少々複雑です。例えば、`let Size s = listSize [1,2]`において、`s`は何になるでしょう？`2`でしょうか？いいえ、`(0 + 1) + 1`を表すサンクになります。

このようなサンクは空間を浪費するだけで、このまま持ち回しても何の意味もなしません。一般にアキュムレーターに関しては、必ずバングパターンでサンクを潰すという暗黙の了解がHaskell界隈にはあります。

というわけで、コードを少し修正してみます。

```haskell
listSize :: [a] -> Size
listSize = go $ Size 0 where
  go s@(Size !_) []    = s
  go (Size !s) (_:xs) = go (Size $ s + 1) xs
```

はい、`!`がついただけですね。これによって、サイズを計算する`listSize`は、次の計算に行く時、引数のパターンマッチによって`s + 1`というサンクが計算されて返るようになります。

ところで、Sizeというデータ型に着目してみると、このデータ型は単純にサイズとなる数値を保持するだけです。そんなデータ型にサンクを保持する必要があるでしょうか？

そもそもデータコンストラクタもサンクとなりえます。そして、データコンストラクタを剥がさない限り中身は見れません。逆に言えばデータコンストラクタを引き剥がす時というのは中身が見たい時ですからその時点で中身がサンクである必要はありません。もし中身を見る必要が無い場合、そもそもデータコンストラクタ自体のサンクを潰すことが無いため、中身については関係ありません。

中身を取り出した時点で、既にデータの構築処理は済んでいるはずです。つまり、その時点でSizeデータの値に必要な計算が行われており、そのサンクが積み上がっていることになります。明らかにその時点でサンクによって余分な空間を消費するよりも、計算してしまった状態でひき回した方がお得です。

一般に、多くのデータはバングパターンによってサンクを潰す方が効率が良く[^1]、Haskell界隈ではデータコンストラクタには何でもバングパターンをつけることが習慣のようになっています。というわけで、`Size`データを修正してみます。

```haskell
data Size = Size !Int deriving (Eq, Ord, Show)
```

さて、最後に、本当にこれによって`listSize`がサンクを潰しているかを見てみます。元のバージョンのデータ型も用意して`trace`を追加して比べてみましょう。

```haskell
listSize :: [a] -> Size
listSize = go $ Size 0 where
  go s []            = s
  go (Size s) (_:xs) = go (Size $ trace "trace: Size consumed" $ s + 1) xs

data SizeL = SizeL Int deriving (Show, Eq, Ord)

listSizeL :: [a] -> SizeL
listSizeL = go $ SizeL 0 where
  go s []             = s
  go (SizeL s) (_:xs) = go (SizeL $ trace "trace: Size consumed" $ s + 1) xs
```

実行結果は、以下のようになります。

```haskell
> (\(Size s) -> const () s) $ listSize [1,2]
trace: Size consumed
trace: Size consumed
()
> (\(SizeL s) -> const () s) $ listSizeL [1,2]
()
```

`SizeL`の方は`trace`が出ていませんが、`Size`の方はちゃんと`trace`がでていて、サンクがちゃんと計算されていることがわかります。

[^1]: 関数の引数などと違い、データはそもそもその形式で保持するものだからです。つまり、ある意味計算の終着点であり、多くの場合そこにサンクを残す必要はありません。実際には、Listなどは遅延評価を利用した多くのコンビネータ（`iterate`など）を抱えていますし、正格にすると`undefined`も評価されてしまうためモナド則などが壊れるといったこともあるため、一概に正格が良いとは言えません。ただし、そこまで厳密に扱わないのであれば、何も考えずにバングパターンを付けておくのは便利です。

## StrictData拡張ってこんなの

GHC8では、StrictPragmaが入りました。詳しくは、[GHC Wiki](https://ghc.haskell.org/trac/ghc/wiki/StrictPragma)をご覧ください。さて、そこではStrict拡張と、StrictData拡張があります。StrictData拡張の方は見ての通り、Strict拡張より機能がとても少ないです。

たったこれだけなのでちょっと訳してみます。

### StrictData

StrictData言語拡張は、非公式に、データ型の定義をデフォルトで正格に切り替え、~を前につけることでフィールドを遅延にする機能を提供するよ。

#### 意味論(Semantics)

ユーザーが次のように書いた時:

```haskell
data T = C a
```

これは、次のように解釈されるよ:

```haskell
data T = C !a
```

今のHaskellは~パターンをデータコンストラクタ内で使用することを許容していないけど、私たちはこれをサポートして、現状の遅延の動作を与えるようにするよ。

この拡張は、このモジュール内の定義のみに作用するよ。 

はい、というわけで、Strictが全てを正格評価で計算する拡張をいれるのに対し、こちらは完全にバングパターンを全てのデータコンストラクタにつけるのに飽きた人たちが、それ専用に作った機能ですね。

この機能を使えば、さっきのような`Size`の例でも!すらつけずにサンクを潰した計算が実装できるようになります。便利ですね。使っていきたい。

# 最後に

簡単なStrictData拡張の紹介をしました。間違いとか、こういう方法あるよとか、あればコメントもらえるとうれしいです。

まあ、ほぼほぼまだGHC7だし、StrictDataをCPPでifdef使ってかき分けなきゃいけなさそう、普通にバングパターン使った方が楽そう。。。悲しいなあ。。。

